---
title: createShader
module: 3D
submodule: Material
file: src/webgl/material.js
description: >
  <p>Crea un nuevo objeto <a href="/reference/p5/p5.Shader">p5.Shader</a>.</p>

  <p>Los shaders son programas que se ejecutan en la unidad de procesamiento gráfico (GPU). Pueden procesar muchos píxeles al mismo tiempo, lo que los hace rápidos para muchas tareas gráficas. Están escritos en un lenguaje llamado <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders" target="_blank">GLSL</a> y se ejecutan junto con el resto del código en un sketch.</p>

  <p>Una vez que se crea el objeto <a href="/reference/p5/p5.Shader">p5.Shader</a>, se puede utilizar con la función <a href="/reference/p5/shader">shader()</a>, como en <code>shader(miShader)</code>. Un programa de shader consta de dos partes, un vertex shader y un fragment shader. El vertex shader afecta dónde se dibuja la geometría 3D en la pantalla y el fragment shader afecta el color.</p>

  <p>El primer parámetro, <code>vertSrc</code>, establece el vertex shader. Es una cadena que contiene el programa del vertex shader escrito en GLSL.</p>

  <p>El segundo parámetro, <code>fragSrc</code>, establece el fragment shader. Es una cadena que contiene el programa del fragment shader escrito en GLSL.</p>

  <p>Nota: Solo se pueden usar shaders de filtro en el modo 2D. Todos los shaders se pueden usar en el modo WebGL.</p>
line: 173
isConstructor: false
itemtype: method
example:
  - |-

    <div modernizr='webgl'>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;

    void main() {
      // Set each pixel's RGBA value to yellow.
      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      let shaderProgram = createShader(vertSrc, fragSrc);

      // Compile and apply the p5.Shader object.
      shader(shaderProgram);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);

      describe('A yellow square.');
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;
    uniform vec2 p;
    uniform float r;
    const int numIterations = 500;
    varying vec2 vTexCoord;

    void main() {
      vec2 c = p + gl_FragCoord.xy * r;
      vec2 z = c;
      float n = 0.0;

      for (int i = numIterations; i > 0; i--) {
        if (z.x * z.x + z.y * z.y > 4.0) {
          n = float(i) / float(numIterations);
          break;
        }
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      }

      gl_FragColor = vec4(
        0.5 - cos(n * 17.0) / 2.0,
        0.5 - cos(n * 13.0) / 2.0,
        0.5 - cos(n * 23.0) / 2.0,
        1.0
      );
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      let mandelbrot = createShader(vertSrc, fragSrc);

      // Compile and apply the p5.Shader object.
      shader(mandelbrot);

      // Set the shader uniform p to an array.
      // p is the center point of the Mandelbrot image.
      mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);

      // Set the shader uniform r to 0.005.
      // r is the size of the image in Mandelbrot-space.
      mandelbrot.setUniform('r', 0.005);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);

      describe('A black fractal image on a magenta background.');
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;
    uniform vec2 p;
    uniform float r;
    const int numIterations = 500;
    varying vec2 vTexCoord;

    void main() {
      vec2 c = p + gl_FragCoord.xy * r;
      vec2 z = c;
      float n = 0.0;

      for (int i = numIterations; i > 0; i--) {
        if (z.x * z.x + z.y * z.y > 4.0) {
          n = float(i) / float(numIterations);
          break;
        }

        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      }

      gl_FragColor = vec4(
        0.5 - cos(n * 17.0) / 2.0,
        0.5 - cos(n * 13.0) / 2.0,
        0.5 - cos(n * 23.0) / 2.0,
        1.0
      );
    }
    `;

    let mandelbrot;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      mandelbrot = createShader(vertSrc, fragSrc);

      // Apply the p5.Shader object.
      shader(mandelbrot);

      // Set the shader uniform p to an array.
      // p is the center point of the Mandelbrot image.
      mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);

      describe('A fractal image zooms in and out of focus.');
    }

    function draw() {
      // Set the shader uniform r to a value that oscillates
      // between 0 and 0.005.
      // r is the size of the image in Mandelbrot-space.
      let radius = 0.005 * (sin(frameCount * 0.01) + 1);
      mandelbrot.setUniform('r', radius);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);
    }
    </code>
    </div>
class: p5
params:
  - name: vertSrc
    description: |
      <p>Código fuente para el vertex shader.</p>
    type: String
  - name: fragSrc
    description: |
      <p>Código fuente para el fragment shader.</p>
    type: String
return:
  description: |-
    Nuevo objeto shader creado a partir de los
    shaders de vértices y fragmentos.
  type: p5.Shader
chainable: false
---


# createShader
