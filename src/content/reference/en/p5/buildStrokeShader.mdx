---
title: buildStrokeShader
module: 3D
submodule: p5.strands
file: src/webgl/material.js
description: >
  <p>Create a new shader that can change how strokes are drawn, based on the
  default

  shader used for strokes. Pass the resulting shader into the

  <a href="/reference/p5/strokeShader/"><code>strokeShader()</code></a> function
  to apply it to any

  strokes you draw.</p>

  <p>The main way to use <code>buildStrokeShader</code> is to pass a function in
  as a parameter.

  This will let you create a shader using p5.strands.</p>

  <p>In your function, you can call hooks to change part of the shader. In a
  material

  shader, these are the hooks available:</p>

  <ul><li><a href="/reference/p5/objectInputs/"><code>objectInputs</code></a>:
  Update vertices before any positioning has been applied. Your function gets
  run on every vertex.</li><li><a
  href="/reference/p5/worldInputs/"><code>worldInputs</code></a>: Update
  vertices after transformations have been applied. Your function gets run on
  every vertex.</li><li><a
  href="/reference/p5/cameraInputs/"><code>cameraInputs</code></a>: Update
  vertices after transformations have been applied, relative to the camera. Your
  function gets run on every vertex.</li><li><a
  href="/reference/p5/pixelInputs/"><code>pixelInputs</code></a>: Update
  property values on pixels on the surface of a shape. Your function gets run on
  every pixel.</li><li><a
  href="/reference/p5/finalColor/"><code>finalColor</code></a>: Update or
  replace the pixel color on the surface of a shape. Your function gets run on
  every pixel.</li></ul><p>Read the linked reference page for each hook for more
  information about how to use them.</p>

  <p>One thing you might want to do is update the color of a stroke per pixel.
  Here, it is being used

  to create a soft texture:</p>

  <pre><code class="language-js example">let myShader;


  function setup() {
    createCanvas(200, 200, WEBGL);
    myShader = buildStrokeShader(material);
  }


  function material() {
    pixelInputs.begin();
    let opacity = 1 - smoothstep(
      0,
      15,
      length(pixelInputs.position - pixelInputs.center)
    );
    pixelInputs.color.a *= opacity;
    pixelInputs.end();
  }


  function draw() {
    background(255);
    strokeShader(myShader);
    strokeWeight(30);
    line(
      -width/3,
      sin(millis()*0.001) * height/4,
      width/3,
      sin(millis()*0.001 + 1) * height/4
    );
  }</code></pre><p>Rather than using opacity, we could use a form of dithering
  to get a different

  texture. This involves using only fully opaque or transparent pixels. Here, we

  randomly choose which pixels to be transparent:</p>

  <pre><code class="language-js example">let myShader;


  function setup() {
    createCanvas(200, 200, WEBGL);
    myShader = buildStrokeShader(material);
  }


  function material() {
    pixelInputs.begin();
    // Replace alpha in the color with dithering by
    // randomly setting pixel colors to 0 based on opacity
    let a = 1;
    if (noise(pixelInputs.position.xy) > pixelInputs.color.a) {
      a = 0;
    }
    pixelInputs.color.a = a;
    pixelInputs.end();
  }


  function draw() {
    background(255);
    strokeShader(myShader);
    strokeWeight(10);
    beginShape();
    for (let i = 0; i <= 50; i++) {
      stroke(
        0,
        255
          * map(i, 0, 20, 0, 1, true)
          * map(i, 30, 50, 1, 0, true)
      );
      vertex(
        map(i, 0, 50, -1, 1) * width/3,
        50 * sin(i/10 + frameCount/100)
      );
    }
    endShape();
  }</code></pre><p>You might also want to update some properties per vertex,
  such as the stroke

  thickness. This lets you create a more varied line:</p>

  <pre><code class="language-js example">let myShader;


  function setup() {
    createCanvas(200, 200, WEBGL);
    myShader = buildStrokeShader(material);
  }


  function material() {
    let time = uniformFloat();
    worldInputs.begin();
    // Add a somewhat random offset to the weight
    // that varies based on position and time
    let scale = 0.5 + noise(
      worldInputs.position.x * 0.01,
      worldInputs.position.y * 0.01,
      time * 0.0005
    );
    worldInputs.weight *= scale;
    worldInputs.end();
  }


  function draw() {
    background(255);
    strokeShader(myShader);
    myShader.setUniform('time', millis());
    strokeWeight(10);
    beginShape();
    for (let i = 0; i <= 50; i++) {
      let r = map(i, 0, 50, 0, width/3);
      let x = r*cos(i*0.2);
      let y = r*sin(i*0.2);
      vertex(x, y);
    }
    endShape();
  }</code></pre><p>Like the <code>modify()</code> method on shaders,

  advanced users can also fill in hooks using <a
  href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders/"
  target="_blank">GLSL</a>

  instead of JavaScript.

  Read the <a href="/reference/p5.Shader/modify/">reference entry for
  <code>modify()</code></a>

  for more info.</p>
line: 2171
isConstructor: false
itemtype: method
example: []
class: p5
return:
  description: The stroke shader.
  type: p5.Shader
overloads:
  - params:
      - name: callback
        description: A function building a p5.strands shader.
        type: Function
    return:
      description: The stroke shader.
      type: p5.Shader
  - params:
      - name: hooks
        description: An object specifying p5.strands hooks in GLSL.
        type: Object
    return:
      description: The stroke shader.
      type: p5.Shader
chainable: false
beta: true
---


# buildStrokeShader
