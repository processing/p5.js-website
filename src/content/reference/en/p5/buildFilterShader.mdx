---
title: buildFilterShader
module: 3D
submodule: p5.strands
file: src/webgl/material.js
description: >
  <p>Creates a <a href="/reference/p5/p5.Shader">p5.Shader</a> object to be used
  with the

  <a href="/reference/p5/filter/">filter()</a> function.</p>

  <p>The main way to use <code>buildFilterShader</code> is to pass a function in
  as a parameter.

  This will let you create a shader using p5.strands.</p>

  <p>In your function, you can use <a
  href="/reference/p5/filterColor/"><code>filterColor</code></a> with a function

  that will be called for each pixel on the image to determine its final color.
  You can

  read the color of the current pixel with <code>getTexture(canvasContent,
  coord)</code>.

  See <a href="/reference/p5/getTexture/">getTexture()</a>.</p>

  <pre><code class="language-js example">async function setup() {
    createCanvas(50, 50, WEBGL);
    let img = await loadImage('/assets/bricks.jpg');
    let myFilter = buildFilterShader(tintShader);

    image(img, -50, -50);
    filter(myFilter);
    describe('Bricks tinted red');
  }


  function tintShader() {
    filterColor.begin();
    let result = getTexture(
      filterColor.canvasContent,
      filterColor.texCoord
    );
    // Zero out the green and blue channels, leaving red
    result.g = 0;
    result.b = 0;
    filterColor.set(result);
    filterColor.end();
  }</code></pre><p>You can create uniforms if you want to pass data into your
  filter from the rest of your sketch.

  For example, you could pass in the mouse cursor position and use that to
  control how much

  you warp the content. If you create a uniform inside the shader using a
  function like <code>uniformFloat()</code>, with

  <code>uniform</code> + the type of the data, you can set its value using
  <code>setUniform</code> right before applying the filter.

  In the example below, move your mouse across the image to see it update the
  <code>warpAmount</code> uniform:</p>

  <pre><code class="language-js example">let img;

  let myFilter;

  async function setup() {
    createCanvas(50, 50, WEBGL);
    img = await loadImage('/assets/bricks.jpg');
    myFilter = buildFilterShader(warpShader);
    describe('Warped bricks');
  }


  function warpShader() {
    let warpAmount = uniformFloat();
    filterColor.begin();
    let coord = filterColor.texCoord;
    coord.y += sin(coord.x * 10) * warpAmount;
    filterColor.set(
      getTexture(filterColor.canvasContent, coord)
    );
    filterColor.end();
  }


  function draw() {
    image(img, -50, -50);
    myFilter.setUniform(
      'warpAmount',
      map(mouseX, 0, width, 0, 1, true)
    );
    filter(myFilter);
  }</code></pre><p>You can also make filters that do not need any content to be
  drawn first!

  There is a lot you can draw just using, for example, the position of the
  pixel.

  <code>inputs.texCoord</code> has an <code>x</code> and a <code>y</code>
  property, each with a number between 0 and 1.</p>

  <pre><code class="language-js example">function setup() {
    createCanvas(50, 50, WEBGL);
    let myFilter = buildFilterShader(gradient);
    describe('A gradient with red, green, yellow, and black');
    filter(myFilter);
  }


  function gradient() {
    filterColor.begin();
    filterColor.set([filterColor.texCoord.x, filterColor.texCoord.y, 0, 1]);
    filterColor.end();
  }</code></pre><pre><code class="language-js example">function setup() {
    createCanvas(50, 50, WEBGL);
    let myFilter = buildFilterShader(gradient);
    describe('A gradient from red to blue');
    filter(myFilter);
  }


  function gradient() {
    filterColor.begin();
    filterColor.set(mix(
      [1, 0, 0, 1], // Red
      [0, 0, 1, 1], // Blue
      filterColor.texCoord.x // x coordinate, from 0 to 1
    ));
    filterColor.end();
  }</code></pre><p>You can also animate your filters over time by passing the
  time into the shader with <code>uniformFloat</code>.</p>

  <pre><code class="language-js example">let myFilter;

  function setup() {
    createCanvas(50, 50, WEBGL);
    myFilter = buildFilterShader(gradient);
    describe('A moving, repeating gradient from red to blue');
  }


  function gradient() {
    let time = uniformFloat();
    filterColor.begin();
    filterColor.set(mix(
      [1, 0, 0, 1], // Red
      [0, 0, 1, 1], // Blue
      sin(filterColor.texCoord.x*15 + time*0.004)/2+0.5
    ));
    filterColor.end();
  }


  function draw() {
    myFilter.setUniform('time', millis());
    filter(myFilter);
  }</code></pre><p>Like the <code>modify()</code> method on shaders,

  advanced users can also fill in <code>filterColor</code> using <a
  href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders/"
  target="_blank">GLSL</a>

  instead of JavaScript.

  Read the <a href="/reference/p5.Shader/modify/">reference entry for
  <code>modify()</code></a>

  for more info. Alternatively, <code>buildFilterShader()</code> can also be
  used like

  <a href="/reference/p5/createShader/">createShader()</a>, but where you only
  specify a fragment shader.</p>

  <p>For more info about filters and shaders, see Adam Ferriss' <a
  href="https://github.com/aferriss/p5jsShaderExamples/">repo of shader
  examples</a>

  or the <a
  href="https://p5js.org/learn/getting-started-in-webgl-shaders.html">Introduction
  to Shaders</a> tutorial.</p>
line: 708
isConstructor: false
itemtype: method
example: []
class: p5
return:
  description: The material shader
  type: p5.Shader
overloads:
  - params:
      - name: callback
        description: A function building a p5.strands shader.
        type: Function
    return:
      description: The material shader
      type: p5.Shader
  - params:
      - name: hooks
        description: An object specifying p5.strands hooks in GLSL.
        type: Object
    return:
      description: The material shader
      type: p5.Shader
chainable: false
beta: true
---


# buildFilterShader
