---
title: async_await
module: Foundation
submodule: Foundation
file: src/core/reference.js
description: >-
  <p>Asynchronous Asset Loading with Async/Await.</p>

  <p>The keywords <code>async</code> and <code>await</code> let you write
  asynchronous code in a more

  straightforward, linear style. Instead of nesting callbacks or juggling

  multiple promise chains, you can pause execution at <code>await</code> while
  waiting

  for a promise to resolve. This makes your code flow more naturally, as if

  it were synchronous.</p>

  <p>When you mark a function with the <code>async</code> keyword—like
  <code>async function setup() {...}</code>—it

  signals that the function contains asynchronous operations and will return a

  promise. Any time you use the <code>await</code> keyword inside this function,
  JavaScript

  will pause the function’s execution until the awaited promise settles.</p>

  <p>In p5.js, you can use <code>async/await</code> to handle media loading
  functions such as

  <code>loadImage()</code>, <code>loadJSON()</code>, <code>loadSound()</code>,
  and so on. This allows you to:</p>

  <ul><li>load files in a more readable, top-to-bottom manner</li><li>decide
  when the assets are fully available before proceeding</li></ul><p>Nested
  callbacks require managing additional information and behavior.

  Lazy loading of assets with <code>async/await</code> can simplify control
  flow,

  but it also requires you to design your sketch around waiting for

  each operation to complete.</p>

  <p>Callbacks are still fully supported, so code that passes success / error

  functions to loaders like <code>loadImage()</code> or <code>loadJSON()</code>
  will behave exactly

  as it always has. This compatibility means sketches written with the older

  pattern don’t need any changes, and you can freely mix callbacks and

  <code>async/await</code> in the same project if that suits your workflow.</p>

  <p>In the example below, <code>setup()</code> is declared as an async
  function. We <code>await</code>

  the completion of both <code>loadImage()</code> and <code>loadJSON()</code>
  before calling

  <code>createCanvas()</code>. Only then does the sketch proceed, guaranteeing
  the assets

  are available for immediate use.</p>

  <pre><code class="language-js">let img, data;


  async function setup() {
    // Wait until the image and JSON data have fully loaded.
    img = await loadImage("./my-image.png");
    data = await loadJSON("./my-data.json");

    // Once the assets are loaded, create the canvas.
    createCanvas(400, 400);
  }</code></pre>
line: 1
isConstructor: false
itemtype: property
example:
  - |-
    <div>
    <code>
    // Click and drag the mouse to view the scene from different angles.

    let shape;

    // Load the file and create a p5.Geometry object.
    async function setup() {
      shape = await loadModel('/assets/teapot.obj');

      createCanvas(100, 100, WEBGL);

      describe('A white teapot drawn against a gray background.');
    }

    function draw() {
      background(200);

      // Enable orbiting with the mouse.
      orbitControl();

      // Draw the shape.
      model(shape);
    }
    </code>
    </div>

    <div>
    <code>
    let font;

    async function setup() {
      // Load a font for WebGL mode.
      font = await loadFont('/assets/inconsolata.otf');

      createCanvas(100, 100, WEBGL);

      describe(
        "A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse."
      );
    }

    function draw() {
      background(200);

      // Style the text.
      textAlign(CENTER);
      textSize(16);
      textFont(font);
      fill(0);

      // Display the mouse's coordinates.
      text(`x: ${mouseX} y: ${mouseY}`, 0, 0);
    }
    </code>
    </div>
class: p5
---


# async\_await
